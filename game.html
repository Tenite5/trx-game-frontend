<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRX Game - Voronoi Hex</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            padding: 30px;
            text-align: center;
            max-width: 700px;
            width: 90%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .game-info {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .game-info p {
            margin: 5px 0;
            font-weight: 500;
        }

        .turn-indicator {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
        }

        .your-turn {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .opponent-turn {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .game-board {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 20px auto;
            border: 3px solid #333;
            border-radius: 10px;
            background: white;
        }

        .voronoi-cell {
            cursor: pointer;
            transition: all 0.2s ease;
            stroke: #333;
            stroke-width: 2;
            fill: #f8f9fa;
        }

        .voronoi-cell:hover:not(.claimed) {
            fill: #e9ecef;
            stroke-width: 3;
        }

        .voronoi-cell.player1 {
            fill: #e74c3c;
            opacity: 0.8;
        }

        .voronoi-cell.player2 {
            fill: #3498db;
            opacity: 0.8;
        }

        .voronoi-cell.disabled {
            cursor: not-allowed;
        }

        .hex-rules {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: left;
        }

        .hex-rules h3 {
            margin-top: 0;
            color: #007bff;
        }

        .side-indicators {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-weight: bold;
        }

        .player1-sides {
            color: #e74c3c;
        }

        .player2-sides {
            color: #3498db;
        }

        .status-message {
            margin: 20px 0;
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
        }

        .waiting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .game-over {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .action-buttons {
            margin-top: 20px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background 0.2s ease;
        }

        button:hover:not(:disabled) {
            background: #0056b3;
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .back-to-dashboard {
            background: #28a745;
        }

        .back-to-dashboard:hover {
            background: #1e7e34;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .game-result {
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .winner {
            background: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }

        .loser {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #dc3545;
        }

        .draw {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Voronoi Hex Battle</h1>
        
        <div class="game-info">
            <p><strong>Player 1:</strong> <span id="player1-name">Loading...</span> (Red)</p>
            <p><strong>Player 2:</strong> <span id="player2-name">Waiting...</span> (Blue)</p>
            <p><strong>Stake:</strong> 10 TRX</p>
            <p><strong>Your Color:</strong> <span id="your-color">-</span></p>
        </div>

        <div class="side-indicators">
            <div class="player1-sides">Player 1: Top ↔ Bottom</div>
            <div class="player2-sides">Player 2: Left ↔ Right</div>
        </div>

        <div class="hex-rules">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Goal:</strong> Connect your assigned sides with a continuous chain</li>
                <li><strong>Player 1 (Red):</strong> Connect TOP to BOTTOM</li>
                <li><strong>Player 2 (Blue):</strong> Connect LEFT to RIGHT</li>
                <li><strong>Rules:</strong> Click to claim cells, first to connect wins!</li>
                <li><strong>Draw:</strong> If board fills without winner, last player to move loses</li>
            </ul>
        </div>

        <div class="turn-indicator" id="turn-indicator">
            <div class="loading"></div>
            Loading game...
        </div>

        <div class="game-board">
            <svg width="500" height="500" id="game-svg">
                <!-- Voronoi cells will be generated here -->
            </svg>
        </div>

        <div class="status-message waiting" id="status-message">
            Connecting to game...
        </div>

        <div class="action-buttons">
            <button id="refresh-game" onclick="refreshGame()">Refresh</button>
            <button class="back-to-dashboard" onclick="goToDashboard()">Back to Dashboard</button>
        </div>
    </div>

    <script>
        const API_URL = 'https://trx-game-backend.onrender.com/api';
        const gameId = new URLSearchParams(window.location.search).get('gameId');
        const token = localStorage.getItem('token');
        
        let gameData = {};
        let gameInterval = null;
        let voronoiCells = [];
        let adjacencyMap = {};
        let boardGenerated = false;

        // Check authentication
        if (!token || !gameId) {
            alert('Invalid game session. Redirecting to dashboard.');
            window.location.href = 'dashboard.html';
        }

        // Generate symmetric Voronoi diagram using D3
        function generateSymmetricVoronoi() {
            const width = 500;
            const height = 500;
            const numPoints = 20; // Generate 20 points in one quadrant = 80 total points
            const basePoints = [];
            
            // Generate random points in one quadrant with varying densities
            for (let i = 0; i < numPoints; i++) {
                // Create clusters and sparse areas for more variety
                const clusterCenter = {
                    x: Math.random() * (width / 2 - 40) + 20,
                    y: Math.random() * (height / 2 - 40) + 20
                };
                
                // Add some clustering effect
                const clusterOffset = Math.random() * 30;
                const angle = Math.random() * 2 * Math.PI;
                
                basePoints.push([
                    Math.max(20, Math.min(width/2 - 20, clusterCenter.x + Math.cos(angle) * clusterOffset)),
                    Math.max(20, Math.min(height/2 - 20, clusterCenter.y + Math.sin(angle) * clusterOffset))
                ]);
            }
            
            // Mirror points to create full symmetry
            const allPoints = [];
            basePoints.forEach(point => {
                const x = point[0], y = point[1];
                // Add all 4 mirror positions
                allPoints.push([x, y]);                           // Original
                allPoints.push([width - x, y]);                  // Horizontal mirror
                allPoints.push([x, height - y]);                 // Vertical mirror  
                allPoints.push([width - x, height - y]);         // Both mirrors
            });

            // Create Delaunay triangulation and Voronoi diagram
            const delaunay = d3.Delaunay.from(allPoints);
            const voronoi = delaunay.voronoi([0, 0, width, height]);
            
            const cells = [];
            for (let i = 0; i < allPoints.length; i++) {
                const cell = voronoi.cellPolygon(i);
                if (cell && cell.length >= 3 && cell.length <= 7) { // Only keep cells with 3-7 sides
                    // Calculate cell area to filter by size
                    const area = calculatePolygonArea(cell);
                    const avgArea = (width * height) / allPoints.length;
                    
                    // Keep cells that are between 0.5x and 2.5x average size
                    if (area > avgArea * 0.5 && area < avgArea * 2.5) {
                        cells.push({
                            id: cells.length, // Reindex to be sequential
                            center: { x: allPoints[i][0], y: allPoints[i][1] },
                            vertices: cell.map(v => ({ x: v[0], y: v[1] })),
                            claimed: false,
                            player: null
                        });
                    }
                }
            }
            
            // Ensure we have at least 16 cells for the game
            if (cells.length < 16) {
                console.warn(`Only generated ${cells.length} valid cells, regenerating...`);
                return generateSymmetricVoronoi(); // Try again
            }
            
            return cells.slice(0, Math.min(64, cells.length)); // Cap at 64 cells for performance
        }

        function calculatePolygonArea(vertices) {
            let area = 0;
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                area += vertices[i][0] * vertices[j][1];
                area -= vertices[j][0] * vertices[i][1];
            }
            return Math.abs(area) / 2;
        }

        function buildAdjacencyMap() {
            adjacencyMap = {};
            console.log(`Building adjacency map for ${voronoiCells.length} cells`);
            
            voronoiCells.forEach((cell, index) => {
                adjacencyMap[index] = [];
                
                voronoiCells.forEach((otherCell, otherIndex) => {
                    if (index !== otherIndex) {
                        // Check if cells share an edge or are very close
                        if (cellsShareEdge(cell, otherCell)) {
                            adjacencyMap[index].push(otherIndex);
                        }
                    }
                });
            });
            
            // Debug output
            console.log('Adjacency map built:', adjacencyMap);
            
            // Ensure every cell has at least one neighbor (fallback)
            voronoiCells.forEach((cell, index) => {
                if (adjacencyMap[index].length === 0) {
                    // Find closest cell as neighbor
                    let closest = null;
                    let closestDist = Infinity;
                    
                    voronoiCells.forEach((otherCell, otherIndex) => {
                        if (index !== otherIndex) {
                            const dist = getDistance(cell.center.x, cell.center.y, otherCell.center.x, otherCell.center.y);
                            if (dist < closestDist) {
                                closestDist = dist;
                                closest = otherIndex;
                            }
                        }
                    });
                    
                    if (closest !== null) {
                        adjacencyMap[index].push(closest);
                        adjacencyMap[closest].push(index); // Make it bidirectional
                    }
                }
            });
        }

        function cellsShareEdge(cell1, cell2) {
            // More aggressive edge detection
            let sharedVertices = 0;
            const threshold = 8; // Increased threshold for "same" vertex
            
            cell1.vertices.forEach(v1 => {
                cell2.vertices.forEach(v2 => {
                    const dist = Math.sqrt((v1.x - v2.x)**2 + (v1.y - v2.y)**2);
                    if (dist < threshold) {
                        sharedVertices++;
                    }
                });
            });
            
            // Also check center distance as fallback
            const centerDist = getDistance(cell1.center.x, cell1.center.y, cell2.center.x, cell2.center.y);
            const avgSize = Math.sqrt(calculatePolygonArea(cell1.vertices.map(v => [v.x, v.y]))) + 
                           Math.sqrt(calculatePolygonArea(cell2.vertices.map(v => [v.x, v.y])));
            
            return sharedVertices >= 2 || centerDist < avgSize * 0.8;
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function renderVoronoiBoard() {
            const svg = document.getElementById('game-svg');
            svg.innerHTML = '';
            
            // Generate cells if not already done
            if (!boardGenerated) {
                voronoiCells = generateSymmetricVoronoi();
                buildAdjacencyMap();
                boardGenerated = true;
            }
            
            // Render each cell
            voronoiCells.forEach((cell, index) => {
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                
                const points = cell.vertices.map(v => `${v.x},${v.y}`).join(' ');
                polygon.setAttribute('points', points);
                polygon.setAttribute('class', 'voronoi-cell');
                polygon.setAttribute('data-cell-id', index);
                
                // Apply player colors
                if (gameData.board && gameData.board[index]) {
                    polygon.classList.add(gameData.board[index] === 'X' ? 'player1' : 'player2');
                    polygon.classList.add('claimed');
                }
                
                // Add click handler
                polygon.addEventListener('click', () => makeMove(index));
                
                svg.appendChild(polygon);
            });
        }

        function checkWinner(board) {
            if (!board || board.length === 0) return null;
            
            // Define edge cells dynamically based on actual cell positions
            const topCells = [];
            const bottomCells = [];
            const leftCells = [];
            const rightCells = [];
            
            const edgeThreshold = 50; // Distance from edge to be considered an edge cell
            
            voronoiCells.forEach((cell, index) => {
                if (cell.center.y < edgeThreshold) topCells.push(index);
                if (cell.center.y > 450) bottomCells.push(index);
                if (cell.center.x < edgeThreshold) leftCells.push(index);
                if (cell.center.x > 450) rightCells.push(index);
            });
            
            // Check if Player 1 (X) connects top to bottom
            const topXCells = topCells.filter(i => board[i] === 'X');
            const bottomXCells = bottomCells.filter(i => board[i] === 'X');
            
            if (topXCells.length > 0 && bottomXCells.length > 0) {
                if (hasPath(topXCells, bottomXCells, 'X', board)) {
                    console.log('Player X wins by connecting top to bottom!');
                    return 'X';
                }
            }
            
            // Check if Player 2 (O) connects left to right
            const leftOCells = leftCells.filter(i => board[i] === 'O');
            const rightOCells = rightCells.filter(i => board[i] === 'O');
            
            if (leftOCells.length > 0 && rightOCells.length > 0) {
                if (hasPath(leftOCells, rightOCells, 'O', board)) {
                    console.log('Player O wins by connecting left to right!');
                    return 'O';
                }
            }
            
            // Check for draw (board full)
            if (board.every(cell => cell !== '')) {
                console.log('Board is full - draw!');
                return 'draw';
            }
            
            return null;
        }

        function hasPath(startCells, endCells, player, board) {
            if (!adjacencyMap || Object.keys(adjacencyMap).length === 0) {
                console.warn('Adjacency map not built yet');
                return false;
            }
            
            const visited = new Set();
            const queue = [...startCells];
            
            console.log(`Checking path for ${player} from cells [${startCells}] to cells [${endCells}]`);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (visited.has(current)) continue;
                visited.add(current);
                
                // Check if we've reached any end cell
                if (endCells.includes(current)) {
                    console.log(`Path found! ${player} connected through cell ${current}`);
                    return true;
                }
                
                // Add adjacent cells of same player
                const neighbors = adjacencyMap[current] || [];
                neighbors.forEach(neighbor => {
                    if (board[neighbor] === player && !visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                });
            }
            
            console.log(`No path found for ${player}`);
            return false;
        }

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            loadGame();
            startGamePolling();
            renderVoronoiBoard();
        });

        async function loadGame() {
            try {
                const response = await fetch(`${API_URL}/game/${gameId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load game');
                }
                
                const data = await response.json();
                gameData = data;
                updateGameDisplay();
            } catch (error) {
                console.error('Load game error:', error);
                document.getElementById('status-message').textContent = 'Failed to load game. Please refresh.';
                document.getElementById('status-message').className = 'status-message error';
            }
        }

        function updateGameDisplay() {
            // Update player names
            document.getElementById('player1-name').textContent = gameData.player1 || 'Loading...';
            document.getElementById('player2-name').textContent = gameData.player2 || 'Waiting for opponent...';
            document.getElementById('your-color').textContent = gameData.yourSymbol === 'X' ? 'Red (Top↔Bottom)' : 'Blue (Left↔Right)';
            
            // Re-render board with current state
            renderVoronoiBoard();
            
            // Update turn indicator and status
            updateTurnIndicator();
            updateGameStatus();
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-indicator');
            
            if (gameData.status === 'queued') {
                indicator.innerHTML = '<div class="loading"></div>Waiting for opponent...';
                indicator.className = 'turn-indicator waiting';
            } else if (gameData.status === 'in_progress') {
                if (gameData.isYourTurn) {
                    indicator.textContent = `Your turn! (${gameData.yourSymbol === 'X' ? 'Red' : 'Blue'})`;
                    indicator.className = 'turn-indicator your-turn';
                } else {
                    indicator.textContent = `${gameData.currentPlayer}'s turn...`;
                    indicator.className = 'turn-indicator opponent-turn';
                }
            } else if (gameData.status === 'completed') {
                indicator.textContent = 'Game Over';
                indicator.className = 'turn-indicator game-over';
            }
        }

        function updateGameStatus() {
            const statusElement = document.getElementById('status-message');
            
            if (gameData.status === 'queued') {
                statusElement.textContent = 'Waiting for opponent to join...';
                statusElement.className = 'status-message waiting';
            } else if (gameData.status === 'in_progress') {
                if (gameData.isYourTurn) {
                    statusElement.textContent = 'Your turn! Click on an empty cell to claim it.';
                    statusElement.className = 'status-message success';
                } else {
                    statusElement.textContent = 'Waiting for opponent\'s move...';
                    statusElement.className = 'status-message waiting';
                }
            } else if (gameData.status === 'completed') {
                showGameResult();
            }
        }

        function showGameResult() {
            const statusElement = document.getElementById('status-message');
            const currentUser = localStorage.getItem('username');
            
            let resultClass = '';
            let resultText = '';
            
            if (gameData.winner === currentUser) {
                resultClass = 'winner';
                resultText = 'Congratulations! You connected your sides and won 19.5 TRX!';
            } else if (gameData.winner && gameData.winner !== currentUser) {
                resultClass = 'loser';
                resultText = 'You lost this round. Your opponent connected their sides first.';
            } else {
                resultClass = 'draw';
                resultText = 'Draw! The last player to move loses. Your stakes have been handled accordingly.';
            }
            
            statusElement.innerHTML = `<div class="game-result ${resultClass}">${resultText}</div>`;
            
            // Stop polling
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
        }

        async function makeMove(position) {
            if (!gameData.isYourTurn || gameData.status !== 'in_progress') {
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/game/${gameId}/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ position })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message);
                }
                
                const data = await response.json();
                
                // Update game data with response
                gameData.board = data.board;
                gameData.status = data.status;
                gameData.isYourTurn = data.isYourTurn;
                
                if (data.winner) {
                    if (data.winner === 'draw') {
                        gameData.winner = null;
                    } else {
                        gameData.winner = data.winner === gameData.yourSymbol ? 
                            localStorage.getItem('username') : 
                            (gameData.yourSymbol === 'X' ? gameData.player2 : gameData.player1);
                    }
                }
                
                updateGameDisplay();
                
            } catch (error) {
                console.error('Move error:', error);
                alert('Failed to make move: ' + error.message);
            }
        }

        function startGamePolling() {
            // Poll every 2 seconds for game updates
            gameInterval = setInterval(() => {
                if (gameData.status !== 'completed') {
                    loadGame();
                } else {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
            }, 2000);
        }

        function refreshGame() {
            loadGame();
        }

        function goToDashboard() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            window.location.href = 'dashboard.html';
        }

        // Clean up interval when page is closed
        window.addEventListener('beforeunload', () => {
            if (gameInterval) {
                clearInterval(gameInterval);
            }
        });
    </script>
</body>
</html>
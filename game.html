<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRX Game - Voronoi Hex</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
            padding: 30px;
            text-align: center;
            max-width: 700px;
            width: 90%;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .game-info {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #007bff;
        }

        .game-info p {
            margin: 5px 0;
            font-weight: 500;
        }

        .turn-indicator {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
        }

        .your-turn {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .opponent-turn {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .game-board {
            position: relative;
            width: 500px;
            height: 500px;
            margin: 20px auto;
            border: 3px solid #333;
            border-radius: 10px;
            background: white;
        }

        .voronoi-cell {
            cursor: pointer;
            transition: all 0.2s ease;
            stroke: #333;
            stroke-width: 2;
            fill: #f8f9fa;
        }

        .voronoi-cell:hover:not(.claimed) {
            fill: #e9ecef;
            stroke-width: 3;
        }

        .voronoi-cell.player1 {
            fill: #e74c3c;
            opacity: 0.8;
        }

        .voronoi-cell.player2 {
            fill: #3498db;
            opacity: 0.8;
        }

        .voronoi-cell.disabled {
            cursor: not-allowed;
        }

        .hex-rules {
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: left;
        }

        .hex-rules h3 {
            margin-top: 0;
            color: #007bff;
        }

        .side-indicators {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-weight: bold;
        }

        .player1-sides {
            color: #e74c3c;
        }

        .player2-sides {
            color: #3498db;
        }

        .status-message {
            margin: 20px 0;
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            border-radius: 8px;
        }

        .waiting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .game-over {
            background: #e2e3e5;
            color: #383d41;
            border: 1px solid #d6d8db;
        }

        .action-buttons {
            margin-top: 20px;
        }

        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: background 0.2s ease;
        }

        button:hover:not(:disabled) {
            background: #0056b3;
        }

        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .back-to-dashboard {
            background: #28a745;
        }

        .back-to-dashboard:hover {
            background: #1e7e34;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .game-result {
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
            padding: 20px;
            border-radius: 10px;
        }

        .winner {
            background: #d4edda;
            color: #155724;
            border: 2px solid #28a745;
        }

        .loser {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #dc3545;
        }

        .draw {
            background: #fff3cd;
            color: #856404;
            border: 2px solid #ffc107;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Voronoi Hex Battle</h1>
        
        <div class="game-info">
            <p><strong>Player 1:</strong> <span id="player1-name">Loading...</span> (Red)</p>
            <p><strong>Player 2:</strong> <span id="player2-name">Waiting...</span> (Blue)</p>
            <p><strong>Stake:</strong> 10 TRX</p>
            <p><strong>Your Color:</strong> <span id="your-color">-</span></p>
        </div>

        <div class="side-indicators">
            <div class="player1-sides">Player 1: Top ↔ Bottom</div>
            <div class="player2-sides">Player 2: Left ↔ Right</div>
        </div>

        <div class="hex-rules">
            <h3>How to Play</h3>
            <ul>
                <li><strong>Goal:</strong> Connect your assigned sides with a continuous chain</li>
                <li><strong>Player 1 (Red):</strong> Connect TOP to BOTTOM</li>
                <li><strong>Player 2 (Blue):</strong> Connect LEFT to RIGHT</li>
                <li><strong>Rules:</strong> Click to claim cells, first to connect wins!</li>
                <li><strong>Draw:</strong> If board fills without winner, last player to move loses</li>
            </ul>
        </div>

        <div class="turn-indicator" id="turn-indicator">
            <div class="loading"></div>
            Loading game...
        </div>

        <div class="game-board">
            <svg width="500" height="500" id="game-svg">
                <!-- Voronoi cells will be generated here -->
            </svg>
        </div>

        <div class="status-message waiting" id="status-message">
            Connecting to game...
        </div>

        <div class="action-buttons">
            <button id="refresh-game" onclick="refreshGame()">Refresh</button>
            <button class="back-to-dashboard" onclick="goToDashboard()">Back to Dashboard</button>
        </div>
    </div>

    <script>
        const API_URL = 'https://trx-game-backend.onrender.com/api';
        const gameId = new URLSearchParams(window.location.search).get('gameId');
        const token = localStorage.getItem('token');
        
        let gameData = {};
        let gameInterval = null;
        let voronoiCells = [];
        let adjacencyMap = {};
        let boardGenerated = false;

        // Check authentication
        if (!token || !gameId) {
            alert('Invalid game session. Redirecting to dashboard.');
            window.location.href = 'dashboard.html';
        }

        // Generate symmetric Voronoi diagram with more exotic shapes
        function generateSymmetricVoronoi() {
            const width = 500;
            const height = 500;
            const basePoints = [];
            
            // Create more irregular distribution for exotic shapes
            const clusters = [
                { x: width/4, y: height/6, count: 3, spread: 80 },
                { x: width/6, y: height/3, count: 2, spread: 60 },
                { x: width/3, y: height/4, count: 4, spread: 90 },
                { x: width/5, y: height/2.5, count: 2, spread: 50 },
                { x: width/2.5, y: height/5, count: 3, spread: 70 }
            ];
            
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    // Use polar coordinates for more irregular placement
                    const angle = (i / cluster.count) * 2 * Math.PI + (Math.random() - 0.5) * Math.PI;
                    const radius = Math.random() * cluster.spread;
                    
                    const x = cluster.x + Math.cos(angle) * radius;
                    const y = cluster.y + Math.sin(angle) * radius;
                    
                    basePoints.push([
                        Math.max(15, Math.min(width/2 - 15, x)),
                        Math.max(15, Math.min(height/2 - 15, y))
                    ]);
                }
            });
            
            // Add some completely random points for more chaos
            for (let i = 0; i < 3; i++) {
                basePoints.push([
                    Math.random() * (width/2 - 30) + 15,
                    Math.random() * (height/2 - 30) + 15
                ]);
            }
            
            // Mirror points to create full symmetry
            const allPoints = [];
            basePoints.forEach(point => {
                const x = point[0], y = point[1];
                allPoints.push([x, y]);                           // Original
                allPoints.push([width - x, y]);                  // Horizontal mirror
                allPoints.push([x, height - y]);                 // Vertical mirror  
                allPoints.push([width - x, height - y]);         // Both mirrors
            });

            // Add boundary points to ensure complete coverage
            const boundaryPoints = [
                [5, 5], [width/2, 5], [width-5, 5],
                [5, height/2], [width-5, height/2],
                [5, height-5], [width/2, height-5], [width-5, height-5]
            ];
            allPoints.push(...boundaryPoints);

            // Create Delaunay triangulation and Voronoi diagram
            const delaunay = d3.Delaunay.from(allPoints);
            const voronoi = delaunay.voronoi([0, 0, width, height]);
            
            const cells = [];
            for (let i = 0; i < allPoints.length; i++) {
                const cell = voronoi.cellPolygon(i);
                if (cell && cell.length >= 3) {
                    const area = calculatePolygonArea(cell);
                    
                    // Keep most cells, only filter out extremely small ones
                    if (area > 50) {
                        cells.push({
                            id: cells.length,
                            center: { x: allPoints[i][0], y: allPoints[i][1] },
                            vertices: cell.map(v => ({ x: v[0], y: v[1] })),
                            claimed: false,
                            player: null
                        });
                    }
                }
            }
            
            console.log(`Generated ${cells.length} exotic cells`);
            return cells;
        }

        function calculatePolygonArea(vertices) {
            let area = 0;
            for (let i = 0; i < vertices.length; i++) {
                const j = (i + 1) % vertices.length;
                area += vertices[i][0] * vertices[j][1];
                area -= vertices[j][0] * vertices[i][1];
            }
            return Math.abs(area) / 2;
        }

        function buildAdjacencyMap() {
            adjacencyMap = {};
            console.log(`Building precise adjacency map for ${voronoiCells.length} cells`);
            
            voronoiCells.forEach((cell, index) => {
                adjacencyMap[index] = [];
                
                voronoiCells.forEach((otherCell, otherIndex) => {
                    if (index !== otherIndex) {
                        if (cellsShareActualEdge(cell, otherCell)) {
                            adjacencyMap[index].push(otherIndex);
                        }
                    }
                });
            });
            
            console.log('Precise adjacency map built:', adjacencyMap);
        }

        function cellsShareActualEdge(cell1, cell2) {
            // Find shared edge segments between two cells
            const sharedSegments = [];
            const tolerance = 3; // Very tight tolerance for shared vertices
            
            // For each edge of cell1, check if it overlaps with any edge of cell2
            for (let i = 0; i < cell1.vertices.length; i++) {
                const v1a = cell1.vertices[i];
                const v1b = cell1.vertices[(i + 1) % cell1.vertices.length];
                
                for (let j = 0; j < cell2.vertices.length; j++) {
                    const v2a = cell2.vertices[j];
                    const v2b = cell2.vertices[(j + 1) % cell2.vertices.length];
                    
                    // Check if edges overlap
                    const overlap = getLineSegmentOverlap(v1a, v1b, v2a, v2b, tolerance);
                    if (overlap && overlap.length > 5) { // Require meaningful overlap length
                        sharedSegments.push(overlap);
                    }
                }
            }
            
            // Cells are adjacent if they share at least one significant edge segment
            const hasSharedEdge = sharedSegments.length > 0;
            
            if (hasSharedEdge) {
                const totalSharedLength = sharedSegments.reduce((sum, seg) => sum + seg.length, 0);
                console.log(`Cells ${cell1.id} and ${cell2.id} share ${totalSharedLength.toFixed(1)}px of edge`);
            }
            
            return hasSharedEdge;
        }

        function getLineSegmentOverlap(p1, p2, p3, p4, tolerance) {
            // Check if line segments (p1,p2) and (p3,p4) overlap
            // Return null if no overlap, or object with overlap length if they do
            
            // Check if the lines are close enough to be considered the same
            if (!linesAreClose(p1, p2, p3, p4, tolerance)) {
                return null;
            }
            
            // Project points onto the line to find overlap
            const line1Start = 0;
            const line1End = getDistance(p1.x, p1.y, p2.x, p2.y);
            
            // Project p3 and p4 onto the line from p1 to p2
            const proj3 = projectPointOntoLine(p3, p1, p2);
            const proj4 = projectPointOntoLine(p4, p1, p2);
            
            const line2Start = Math.min(proj3, proj4);
            const line2End = Math.max(proj3, proj4);
            
            // Find overlap
            const overlapStart = Math.max(line1Start, line2Start);
            const overlapEnd = Math.min(line1End, line2End);
            
            if (overlapStart < overlapEnd) {
                return { length: overlapEnd - overlapStart };
            }
            
            return null;
        }

        function linesAreClose(p1, p2, p3, p4, tolerance) {
            // Check if two line segments are close enough to be considered adjacent
            const dist1 = distanceFromPointToLineSegment(p3, p1, p2);
            const dist2 = distanceFromPointToLineSegment(p4, p1, p2);
            const dist3 = distanceFromPointToLineSegment(p1, p3, p4);
            const dist4 = distanceFromPointToLineSegment(p2, p3, p4);
            
            return (dist1 <= tolerance && dist2 <= tolerance) || 
                   (dist3 <= tolerance && dist4 <= tolerance);
        }

        function projectPointOntoLine(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) return 0;
            
            const param = dot / lenSq;
            return param * Math.sqrt(lenSq);
        }

        function distanceFromPointToLineSegment(point, lineStart, lineEnd) {
            const A = point.x - lineStart.x;
            const B = point.y - lineStart.y;
            const C = lineEnd.x - lineStart.x;
            const D = lineEnd.y - lineStart.y;
            
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            
            if (lenSq === 0) {
                return Math.sqrt(A * A + B * B);
            }
            
            let param = dot / lenSq;
            
            let xx, yy;
            if (param < 0) {
                xx = lineStart.x;
                yy = lineStart.y;
            } else if (param > 1) {
                xx = lineEnd.x;
                yy = lineEnd.y;
            } else {
                xx = lineStart.x + param * C;
                yy = lineStart.y + param * D;
            }
            
            const dx = point.x - xx;
            const dy = point.y - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getDistance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        function renderVoronoiBoard() {
            const svg = document.getElementById('game-svg');
            svg.innerHTML = '';
            
            // Generate cells if not already done
            if (!boardGenerated) {
                voronoiCells = generateSymmetricVoronoi();
                buildAdjacencyMap();
                boardGenerated = true;
                initializeBoard(); // Initialize backend board
            }
            
            // Render each cell
            voronoiCells.forEach((cell, index) => {
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                
                const points = cell.vertices.map(v => `${v.x},${v.y}`).join(' ');
                polygon.setAttribute('points', points);
                polygon.setAttribute('class', 'voronoi-cell');
                polygon.setAttribute('data-cell-id', index);
                
                // Apply player colors
                if (gameData.board && gameData.board[index]) {
                    polygon.classList.add(gameData.board[index] === 'X' ? 'player1' : 'player2');
                    polygon.classList.add('claimed');
                }
                
                // Disable clicks if not player's turn or game not in progress
                if (!gameData.isYourTurn || gameData.status !== 'in_progress' || (gameData.board && gameData.board[index] !== '')) {
                    polygon.classList.add('disabled');
                }
                
                // Add click handler
                polygon.addEventListener('click', () => makeMove(index));
                
                svg.appendChild(polygon);
            });
        }

        // Initialize board layout on backend
        async function initializeBoard() {
            try {
                // Build edge cells based on actual positions
                const edgeCells = {
                    top: [],
                    bottom: [],
                    left: [],
                    right: []
                };
                
                const edgeThreshold = 50;
                voronoiCells.forEach((cell, index) => {
                    if (cell.center.y < edgeThreshold) edgeCells.top.push(index);
                    if (cell.center.y > 450) edgeCells.bottom.push(index);
                    if (cell.center.x < edgeThreshold) edgeCells.left.push(index);
                    if (cell.center.x > 450) edgeCells.right.push(index);
                });
                
                console.log('Edge cells:', edgeCells);
                console.log('Board size:', voronoiCells.length);
                
                // Send board layout to server
                const response = await fetch(`${API_URL}/game/${gameId}/init-board`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        boardSize: voronoiCells.length,
                        edgeCells,
                        adjacencyMap
                    })
                });
                
                if (!response.ok) {
                    console.error('Failed to initialize board on backend');
                }
            } catch (error) {
                console.error('Failed to initialize board:', error);
            }
        }

        function checkWinner(board) {
            if (!board || board.length === 0) return null;
            
            // Define edge cells dynamically based on actual cell positions
            const topCells = [];
            const bottomCells = [];
            const leftCells = [];
            const rightCells = [];
            
            const edgeThreshold = 50; // Distance from edge to be considered an edge cell
            
            voronoiCells.forEach((cell, index) => {
                if (cell.center.y < edgeThreshold) topCells.push(index);
                if (cell.center.y > 450) bottomCells.push(index);
                if (cell.center.x < edgeThreshold) leftCells.push(index);
                if (cell.center.x > 450) rightCells.push(index);
            });
            
            // Check if Player 1 (X) connects top to bottom
            const topXCells = topCells.filter(i => board[i] === 'X');
            const bottomXCells = bottomCells.filter(i => board[i] === 'X');
            
            if (topXCells.length > 0 && bottomXCells.length > 0) {
                if (hasPath(topXCells, bottomXCells, 'X', board)) {
                    console.log('Player X wins by connecting top to bottom!');
                    return 'X';
                }
            }
            
            // Check if Player 2 (O) connects left to right
            const leftOCells = leftCells.filter(i => board[i] === 'O');
            const rightOCells = rightCells.filter(i => board[i] === 'O');
            
            if (leftOCells.length > 0 && rightOCells.length > 0) {
                if (hasPath(leftOCells, rightOCells, 'O', board)) {
                    console.log('Player O wins by connecting left to right!');
                    return 'O';
                }
            }
            
            // Check for draw (board full)
            if (board.every(cell => cell !== '')) {
                console.log('Board is full - draw!');
                return 'draw';
            }
            
            return null;
        }

        function hasPath(startCells, endCells, player, board) {
            if (!adjacencyMap || Object.keys(adjacencyMap).length === 0) {
                console.warn('Adjacency map not built yet');
                return false;
            }
            
            const visited = new Set();
            const queue = [...startCells];
            
            console.log(`Checking path for ${player} from cells [${startCells}] to cells [${endCells}]`);
            
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (visited.has(current)) continue;
                visited.add(current);
                
                // Check if we've reached any end cell
                if (endCells.includes(current)) {
                    console.log(`Path found! ${player} connected through cell ${current}`);
                    return true;
                }
                
                // Add adjacent cells of same player
                const neighbors = adjacencyMap[current] || [];
                neighbors.forEach(neighbor => {
                    if (board[neighbor] === player && !visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                });
            }
            
            console.log(`No path found for ${player}`);
            return false;
        }

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            loadGame();
            startGamePolling();
            renderVoronoiBoard();
        });

        async function loadGame() {
            try {
                const response = await fetch(`${API_URL}/game/${gameId}`, {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to load game');
                }
                
                const data = await response.json();
                gameData = data;
                updateGameDisplay();
            } catch (error) {
                console.error('Load game error:', error);
                document.getElementById('status-message').textContent = 'Failed to load game. Please refresh.';
                document.getElementById('status-message').className = 'status-message error';
            }
        }

        function updateGameDisplay() {
            // Update player names
            document.getElementById('player1-name').textContent = gameData.player1 || 'Loading...';
            document.getElementById('player2-name').textContent = gameData.player2 || 'Waiting for opponent...';
            document.getElementById('your-color').textContent = gameData.yourSymbol === 'X' ? 'Red (Top↔Bottom)' : 'Blue (Left↔Right)';
            
            // Re-render board with current state
            renderVoronoiBoard();
            
            // Update turn indicator and status
            updateTurnIndicator();
            updateGameStatus();
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turn-indicator');
            
            if (gameData.status === 'queued') {
                indicator.innerHTML = '<div class="loading"></div>Waiting for opponent...';
                indicator.className = 'turn-indicator waiting';
            } else if (gameData.status === 'in_progress') {
                if (gameData.isYourTurn) {
                    indicator.textContent = `Your turn! (${gameData.yourSymbol === 'X' ? 'Red' : 'Blue'})`;
                    indicator.className = 'turn-indicator your-turn';
                } else {
                    indicator.textContent = `${gameData.currentPlayer}'s turn...`;
                    indicator.className = 'turn-indicator opponent-turn';
                }
            } else if (gameData.status === 'completed') {
                indicator.textContent = 'Game Over';
                indicator.className = 'turn-indicator game-over';
            }
        }

        function updateGameStatus() {
            const statusElement = document.getElementById('status-message');
            
            if (gameData.status === 'queued') {
                statusElement.textContent = 'Waiting for opponent to join...';
                statusElement.className = 'status-message waiting';
            } else if (gameData.status === 'in_progress') {
                if (gameData.isYourTurn) {
                    statusElement.textContent = 'Your turn! Click on an empty cell to claim it.';
                    statusElement.className = 'status-message success';
                } else {
                    statusElement.textContent = 'Waiting for opponent\'s move...';
                    statusElement.className = 'status-message waiting';
                }
            } else if (gameData.status === 'completed') {
                showGameResult();
            }
        }

        function showGameResult() {
            const statusElement = document.getElementById('status-message');
            const currentUser = localStorage.getItem('username');
            
            let resultClass = '';
            let resultText = '';
            
            if (gameData.winner === currentUser) {
                resultClass = 'winner';
                resultText = 'Congratulations! You connected your sides and won 19.5 TRX!';
            } else if (gameData.winner && gameData.winner !== currentUser) {
                resultClass = 'loser';
                resultText = 'You lost this round. Your opponent connected their sides first.';
            } else {
                resultClass = 'draw';
                resultText = 'Draw! The last player to move loses. Your stakes have been handled accordingly.';
            }
            
            statusElement.innerHTML = `<div class="game-result ${resultClass}">${resultText}</div>`;
            
            // Stop polling
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
        }

        async function makeMove(position) {
            if (!gameData.isYourTurn || gameData.status !== 'in_progress') {
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/game/${gameId}/move`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({ position })
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message);
                }
                
                const data = await response.json();
                
                // Update game data with response
                gameData.board = data.board;
                gameData.status = data.status;
                gameData.isYourTurn = data.isYourTurn;
                
                if (data.winner) {
                    if (data.winner === 'draw') {
                        gameData.winner = null;
                    } else {
                        gameData.winner = data.winner === gameData.yourSymbol ? 
                            localStorage.getItem('username') : 
                            (gameData.yourSymbol === 'X' ? gameData.player2 : gameData.player1);
                    }
                }
                
                updateGameDisplay();
                
            } catch (error) {
                console.error('Move error:', error);
                alert('Failed to make move: ' + error.message);
            }
        }

        function startGamePolling() {
            // Poll every 2 seconds for game updates
            gameInterval = setInterval(() => {
                if (gameData.status !== 'completed') {
                    loadGame();
                } else {
                    clearInterval(gameInterval);
                    gameInterval = null;
                }
            }, 2000);
        }

        function refreshGame() {
            loadGame();
        }

        function goToDashboard() {
            if (gameInterval) {
                clearInterval(gameInterval);
                gameInterval = null;
            }
            
            // Forfeit the game if it's in progress
            if (gameData.status === 'in_progress') {
                const shouldForfeit = confirm('Leaving will forfeit the game and you will lose. Are you sure?');
                if (!shouldForfeit) {
                    return; // Don't leave if user cancels
                }
                
                // Send forfeit request
                forfeitGame().then(() => {
                    window.location.href = 'dashboard.html';
                });
            } else {
                window.location.href = 'dashboard.html';
            }
        }

        async function forfeitGame() {
            try {
                await fetch(`${API_URL}/game/${gameId}/forfeit`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
            } catch (error) {
                console.error('Failed to forfeit game:', error);
            }
        }

        // Also handle page close/refresh
        window.addEventListener('beforeunload', (e) => {
            if (gameData.status === 'in_progress') {
                e.preventDefault();
                e.returnValue = 'Leaving will forfeit the game and you will lose. Are you sure?';
                
                // Send forfeit in background (may not always work due to browser limitations)
                navigator.sendBeacon(`${API_URL}/game/${gameId}/forfeit`, JSON.stringify({}));
            }
            
            if (gameInterval) {
                clearInterval(gameInterval);
            }
        });
    </script>
</body>
</html>